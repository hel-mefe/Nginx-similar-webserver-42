# include "http_parser.class.hpp"

// mainly used for methods

bool    HttpParser::is_request_uri_valid(std::string &path)
{
    for (int i = 0; i < sz(path); i++)
    {
        if (!isalnum(path[i]) && path[i] != '/' && path[i] != '.' && path[i] != '-' && path[i] != '_')
            return (false) ;
    }
    return (true) ;
}

std::string HttpParser::get_upper_case(std::string s)
{
    std::string res = s;

    for (int i = 0; i < sz(s); i++)
    {
        if (isalpha(s[i]) && islower(s[i]))
            res[i] = toupper(s[i]);
    }
    return res ;
}

// mainly used for request parameters
std::string HttpParser::get_lower_case(std::string s)
{
    std::string res = s;

    for (int i = 0; i < sz(s); i++)
    {
        if (isalpha(s[i]) && isupper(s[i]))
            res[i] = tolower(s[i]);
    }
    return res;
}

std::string HttpParser::get_extension(std::string &s)
{
    std::string ext;
    int i = sz(s) - 1;

    for (; i >= 0 && s[i] != '.'; i--);
    if (i >= 0 && s[i] == '.')
        ext = s.substr(i, sz(s) - i);
    return ext;
}

bool    is_file(std::string &path)
{
    int i = sz(path) - 1;

    for (; i >= 0 && path[i] != '/' && path[i] != '.'; i--);
    return (i >= 0 && path[i] == '.') ;
}

std::string trim_string(std::string &s)
{
    int a = 0, b = sz(s) - 1;
    while (a < b && isspace(s[a]) && isspace(s[b]))
        a += (isspace(s[a])), b -= (isspace(s[a]));        
    std::string res = s.substr(a, b - a + 1);
    return res;
}


std::vector<std::string>    *HttpParser::split_first_line(std::string &s)
{
    std::vector<std::string>    *splitted = new std::vector<std::string>();
    bool flag = false;
    int i = 0;
    for (; i < sz(s) && isspace(s[i]); i++);
    while (i < sz(s) && sz((*splitted)) != 3)
    {
        if (!isspace(s[i]))
        {
            int a = i;
            while(i < sz(s) && !isspace(s[i]))
                i++;
            std::string substring = s.substr(a, i - a);
            std::string res = trim_string(substring);
            splitted->push_back(res);
        }
        else
            i++;
    }
    return (splitted);
}

bool    HttpParser::read_header(t_client *client)
{
    char buff[MAX_BUFFER_SIZE];
    int bytes;
    std::string lines;
    bool header_complete = false ;

    bzero(buff, MAX_BUFFER_SIZE);
    bytes = read(client->fd, buff, MAX_BUFFER_SIZE);
    if (bytes < 0)
        return (false);
    if (!bytes)
    {
        client->state = SERVED;
        return (false);
    }
    lines = buff;
    std::stringstream strm(lines);
    while (strm.good() && !header_complete)
    {
        std::string line;
        std::getline(strm, line);
        if (line[sz(line) - 1] == '\r')
            line = line.substr(0, sz(line) - 1);
        header_complete = !sz(line);
        if (sz(line) && !header_complete)
            client->request->lines.push_back(line);
    }
    return (header_complete);
}

void    HttpParser::parse_first_line(t_request *req)
{
    std::string line = req->lines[0];
    std::string method, path, http_version;
    int i = 0, k = 0;
    std::vector<std::string> *splitted = split_first_line(line);

    std::cout << "VECTOR LEN -> " << sz((*splitted)) << std::endl;
    req->method = get_upper_case(splitted->at(0));
    req->path = splitted->at(1);
    std::cout << RED_BOLD << "PATH IN REQUEST -> " << req->path << std::endl;
    req->http_version = get_upper_case(splitted->at(2));
    req->is_file = is_file(req->path);
    if (req->is_file)
        req->extension = get_extension(req->path);
    delete splitted;
}

void    HttpParser::parse_request(t_client *client)
{
    t_request *req;

    req = client->request;
    parse_first_line(req);
    for (int i = 1; i < sz(req->lines); i++)
    {
        std::string line = req->lines[i], first, second;
    
        int j = 0, a = 0;
        for (; j < sz(line) && isspace(line[j]); j++);
        a = j;
        for (; j < sz(line) && line[j] != ':'; j++);
        first = get_lower_case(line.substr(a, j - a));
    
        for (; j < sz(line) && isspace(line[j]); j++);
        a = j;
        for (; j < sz(line) && line[j] != '\r'; j++);
        second = get_lower_case(line.substr(a, j - a));
        first = trim_string(first);
        second = trim_string(second);
        req->request_map.insert(std::make_pair(first, second));
    }
    /****** START PRINTING REQUEST ******/

    // std::cout << WHITE << "***** PRINTING REQUEST MAP *****" << std::endl;
    // for (auto x: req->request_map)
    //     std::cout << x.first << " " << x.second << std::endl;
    // std::cout << "***** END PRINTING REQUEST MAP *****" << std::endl;

    /****** END PRINTING REQUEST *****/
}